<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>A Rambling Mind on A Rambling Mind </title>
    <link>https://fungos.github.io/</link>
    <language>en-us</language>
    <author>Danny Grein</author>
    <updated>2017-11-20 22:00:00 -0500 EST</updated>
    
    <item>
      <title>cr.h: A Simple C Hot Reload Header-only Library</title>
      <link>https://fungos.github.io/blog/2017/11/20/cr.h-a-simple-c-hot-reload-header-only-library/</link>
      <pubDate>Mon, 20 Nov 2017 22:00:00 EST</pubDate>
      <author>Alexander Ivanov</author>
      <guid>https://fungos.github.io/blog/2017/11/20/cr.h-a-simple-c-hot-reload-header-only-library/</guid>
      <description>

&lt;p&gt;Recently I&amp;rsquo;ve been back to hobby coding simple C stuff, and one project that I&amp;rsquo;m doing with a friend tries to simple emulate some old game. The idea is really basic, but we want to do it in the C-style without over engineering or losing track of the hobby feeling.&lt;/p&gt;

&lt;p&gt;But! It is really hard to not care at least a bit, even if it is just hobby stuff. I got literally side-tracked at one point and here I describe why and the resulting product of this.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/08a269b19513df8325a177ff96e4e387f36b5bbf/68747470733a2f2f692e696d6775722e636f6d2f4e7136733047502e676966&#34; alt=&#34;ImGui with cr.h&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-problem&#34;&gt;The &amp;ldquo;Problem&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;While prototyping a functionality in this project, I wanted to be able to quickly iterate trying some ideas. My first reaction was that having a scripting language from the start would be a benefit for testing out ideas in a fast-paced way, but at the same time that would easily get in the way (by requiring bindings and maintenance) considering the time available for some hobby coding. On the other side, something that wouldn&amp;rsquo;t get in the way would be doing it in a way as close as possible of the C and with less boilerplate possible, helping us keep the focus on the project itself.&lt;/p&gt;

&lt;p&gt;If what we wanted is something close to C, it could be done in at least two ways:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a script based on a C subset (preferable compilable to C); or,&lt;/li&gt;
&lt;li&gt;run-time hot-reload for live coding;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;
Independent of which way we decided to go with, I had already some expectations about it, I wanted something that respected most of the following requirements, loosely based on my priorities for a hobby project:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;easy to use;&lt;/li&gt;
&lt;li&gt;requires the minimum amount of boilerplate;&lt;/li&gt;
&lt;li&gt;easy to maintain;&lt;/li&gt;
&lt;li&gt;fast;&lt;/li&gt;
&lt;li&gt;independent of build system and not requiring custom build steps or anything;&lt;/li&gt;
&lt;li&gt;closest possible to the C-family syntax (ie. Lua was a big NO);&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-options&#34;&gt;The &amp;ldquo;Options&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve checked some scripting languages and none of them fit most of the listed requirements. The better ones are slow or complex and the faster ones (as Lua) have annoying syntax. I mostly based my evaluation on &lt;a href=&#34;https://github.com/r-lyeh/scriptorium&#34;&gt;this&lt;/a&gt; very nice listing with some benchmarks and code samples.&lt;/p&gt;

&lt;p&gt;In the other hand, creating a kind of C script is not that simple, it requires much more code to achieve something usable than integrating some ready-to-use scripting language. There is a bunch of libraries and tools that can help, like embedding a simple compiler as &lt;a href=&#34;https://bellard.org/tcc/&#34;&gt;TCC&lt;/a&gt; or one complex as &lt;a href=&#34;https://clang.llvm.org/docs/Tooling.html&#34;&gt;libclang/libtooling&lt;/a&gt;, or even maybe something that already embedded the compiler for us, as &lt;a href=&#34;https://github.com/anael-seghezzi/CToy&#34;&gt;C-Toy&lt;/a&gt; or &lt;a href=&#34;https://root.cern.ch/cint&#34;&gt;CINT&lt;/a&gt;. But that adds a lot of dependency code, requires too much fiddling with build systems, still requires writing bindings and aren&amp;rsquo;t really &lt;em&gt;easy to use&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The other option would be doing hot-reloading of the runtime code as we change it. Even if this may appear complex, it is at least not as complex as to write a simple language. One downside is that opposed to scripts, this area does not have much public content in both articles and source code forms. Luckily enough, this idea fits with my concept of hobby stuff and is doable in my free time.&lt;/p&gt;

&lt;h3 id=&#34;hot-reloading&#34;&gt;Hot Reloading&lt;/h3&gt;

&lt;p&gt;One very known solution is &lt;a href=&#34;https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus&#34;&gt;RuntimeCompiledCPlusPlus (RC++)&lt;/a&gt;, other than that, there is nothing else &lt;strong&gt;ready-to-use&lt;/strong&gt; even if this is a somewhat common practice privately. So first, lets thanks &lt;a href=&#34;https://www.enkisoftware.com/about#doug&#34;&gt;Doug Binks&lt;/a&gt; and &lt;a href=&#34;https://www.enkisoftware.com&#34;&gt;enkisoftware&lt;/a&gt; for publishing RC++ with an open source license, this is a much required improvement over the situation.&lt;/p&gt;

&lt;p&gt;RC++ is a full featured solution, and this comes with its own amount of complexity. On my case, I didn&amp;rsquo;t need all features it offers, but I strongly recommends evaluating it when deciding which solution to take as each one has its pros and cons. To know more about its design and usage I recommend reading &lt;a href=&#34;http://runtimecompiledcplusplus.blogspot.ca/2016/04/runtime-compiled-c-article-available.html&#34;&gt;this article&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Another good thing about RC++ is that it has listing of some &lt;a href=&#34;https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus/wiki/Alternatives&#34;&gt;alternatives&lt;/a&gt; solutions on code hot-reloading, including some nice posts by people that use it for actual development like &lt;a href=&#34;http://ourmachinery.com/post/dll-hot-reloading-in-theory-and-practice/&#34;&gt;this post&lt;/a&gt; from &lt;a href=&#34;http://ourmachinery.com/&#34;&gt;Our Machinery&lt;/a&gt;. Sadly, none of the projects with source code seems ready to use, as they look more like experimentation projects and most of them if not all, don&amp;rsquo;t have multi platform support or are simple barely usable at all.&lt;/p&gt;

&lt;p&gt;So, I decided to write one that I hope to be simple but also usable by anyone:&lt;/p&gt;

&lt;h2 id=&#34;cr-h-the-c-reloader&#34;&gt;cr.h: the c reloader&lt;/h2&gt;

&lt;p&gt;Considering the requirements for our hobby project listed before, in a public and open source project these requirements would become:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;simple to use, but not basic;&lt;/li&gt;
&lt;li&gt;less intrusive possible;&lt;/li&gt;
&lt;li&gt;reusable to anyone, not only specific to my needs;&lt;/li&gt;
&lt;li&gt;avoid build system customization or dependency;&lt;/li&gt;
&lt;li&gt;linux and windows at least (macosx is a bonus);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;
The first four points are related to user experience and the last one is a minimum expected from any meaningful public project.&lt;/p&gt;

&lt;p&gt;Being simple and reusable comes with not being too intrusive and having a simple public API. If anyone other than me decide to use it, it should not require learning a lot of details of how it works nor requiring deep changes in existing code. But also, not requiring complex changes to existing building system or scripts to do some magic in the background.&lt;/p&gt;

&lt;h3 id=&#34;overview-and-usage&#34;&gt;Overview and Usage&lt;/h3&gt;

&lt;p&gt;Before implementing &lt;code&gt;cr.h&lt;/code&gt;, I read everything I could find about how people deal with this and what the most frequent problems and issues. I will try to explain how my implementation differ from others and how I&amp;rsquo;ve solved some of the more common issues.&lt;/p&gt;

&lt;p&gt;The core of the system is really basic and do not differ from most of the home grown solutions. The idea is to split the code into a thin host application executable and the core of the program into a dynamically loadable binary (shared object or dll) guest.&lt;/p&gt;

&lt;p&gt;The less the host needs to know the better and easier it becomes. Ideally it should just be able to load the binary, monitor for new updates, unload the current one saving any required state then loading the new up-to-date binary and passing over the saved state, repeating the process until terminated by the user.&lt;/p&gt;

&lt;p&gt;The usage is really simple, the very first thing is to initialize the system with &lt;code&gt;cr_plugin_init&lt;/code&gt;, a &lt;code&gt;cr_plugin&lt;/code&gt; context and the fullpath to the loadable object (ie. a .so or .dll). Once initialized, the main function &lt;code&gt;cr_plugin_update&lt;/code&gt; must be frequently called, as it will call the real application and it will deal with all the reloading and monitoring stuff. Finally, when the application wants to exit, &lt;code&gt;cr_plugin_close&lt;/code&gt; will do all the required cleanup. This is all the public API when using &lt;code&gt;cr.h&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;cr_plugin&lt;/code&gt; context contains some internal private stuff, but also some information useful to the application itself. One is the &lt;code&gt;version&lt;/code&gt; field, a value incremented each time a reload is successful or decremented in case of a rollback. Rollbacks may happen when a crash or an issue is detected, the system will try to safely unload the problematic binary and reload a previous working one. In case of rollback, a &lt;code&gt;failure&lt;/code&gt; code will be set in the plugin context and the new loaded binary may use this information to give some useful feedback or dealing with it in an appropriate fashion for the application.&lt;/p&gt;

&lt;p&gt;Once up and running, each time the loadable binary is rebuilt, &lt;code&gt;cr.h&lt;/code&gt; will trigger a reload as it is monitoring for file changes based on the file time stamp. Each time an update, a load or an unload happens, &lt;code&gt;cr.h&lt;/code&gt; will pass the info down to the application by using the &lt;code&gt;cr_op&lt;/code&gt; operation flag: &lt;code&gt;CR_LOAD&lt;/code&gt;, &lt;code&gt;CR_STEP&lt;/code&gt; or &lt;code&gt;CR_UNLOAD&lt;/code&gt;. For example, in case of unload the application may be able to intercept and deal with something before the binary is fully unloaded (like saving some internal state).&lt;/p&gt;

&lt;p&gt;This is everything needed to live code reload using &lt;code&gt;cr.h&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;However, how does &lt;code&gt;cr.h&lt;/code&gt; deal with the issues cited over the other articles about hot-reloading? How to manage state between reloads? What about the common PDB locking that people frequently have on windows? &lt;code&gt;cr.h&lt;/code&gt; tries to solve these problems without any workaround or tricks with build systems.&lt;/p&gt;

&lt;h4 id=&#34;problem-pdb-lock&#34;&gt;Problem: PDB Lock&lt;/h4&gt;

&lt;p&gt;One recurring theme when doing hot-reloading on windows with a MSVC toolchain is the PDB lock while debugging. One instance of this issue can be seen &lt;a href=&#34;http://ourmachinery.com/post/dll-hot-reloading-in-theory-and-practice/&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;http://ourmachinery.com/post/little-machines-working-together-part-2/&#34;&gt;here&lt;/a&gt;. These posts lists some possible solutions and problems with each solution, and it goes way down to trying to force unlock the file handles on windows as seen &lt;a href=&#34;https://blog.molecular-matters.com/2017/05/09/deleting-pdb-files-locked-by-visual-studio/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cr.h&lt;/code&gt; solves this in a pragmatic and simple way, first it starts by copying the &lt;code&gt;.dll&lt;/code&gt; and the &lt;code&gt;.pdb&lt;/code&gt; with a new versioned name and then we fix the real issue, that is not the file lock.&lt;/p&gt;

&lt;p&gt;When debugging, the debugger needs a way to find for the debug symbols, and in the MSVC toolchain this comes in the form of a second file, the &lt;code&gt;.pdb&lt;/code&gt; that may exist elsewhere in the filesystem. So when generating the executable it will write the path to the matching PDB file inside the binary to be debugged. It literally contains the full path to the &lt;code&gt;.pdb&lt;/code&gt; hardcoded inside it and the debugger will load this file causing a lock. You can check this yourself by doing a &lt;code&gt;strings&lt;/code&gt; on the &lt;code&gt;.dll&lt;/code&gt; or opening it with a hex editor and searching for the substring &lt;code&gt;.pdb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The only thing needed to do to avoid the lock to happen, is to literally change this string to point to our own copy of &lt;code&gt;.pdb&lt;/code&gt; and thus guaranteeing that the debugger will lock our copy and not the original file while debugging.&lt;/p&gt;

&lt;p&gt;This can be done the brute-force but brittle way (searching and replacing the string), or the right way by doing what the debugger does: correctly opening and parsing the binary structures and modifying it. There are a lot of documentation on the &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/ms809762.aspx&#34;&gt;Portable Executable format&lt;/a&gt; and how to parse it, or more specifically on how to find the &lt;a href=&#34;http://www.debuginfo.com/articles/debuginfomatch.html&#34;&gt;debugging information&lt;/a&gt; as reference for more details on the subject.&lt;/p&gt;

&lt;p&gt;With this simple solution we can debug and rebuild at the same time even during reloads, the debugger will find the correct debug info and be up-to-date with the current debugged binary as we modify it.&lt;/p&gt;

&lt;h4 id=&#34;problem-crashes&#34;&gt;Problem: Crashes&lt;/h4&gt;

&lt;p&gt;While live coding, the chances to introduce problems are high as we get into a faster development flow. So if we can avoid crashing due to erroneous code, it will help keeping with this faster flow. Hence, &lt;code&gt;cr.h&lt;/code&gt; tries to be helpful and to detect crashes and safely continuing the execution from a previous working version. This system is not unbreakable as at the end we are dealing with C/C++ and there are just too many ways to shoot yourself.&lt;/p&gt;

&lt;p&gt;In practice, &lt;code&gt;cr.h&lt;/code&gt; tries to emulate the debugger here too. On windows it will use &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680657(v=vs.85).aspx&#34;&gt;structured exception handling&lt;/a&gt; to detect some common problems as illegal instruction, access violation and some others. In which case, &lt;code&gt;cr.h&lt;/code&gt; will catch it and try to unload the problematic binary and revert back to the previous working one, effectively doing a rollback.
Over Linux, the same happens but it is managed using the OS signal handlers.&lt;/p&gt;

&lt;p&gt;All this enables a seamsly development flow that is pleasing to use.&lt;/p&gt;

&lt;h4 id=&#34;problem-state-transfer&#34;&gt;Problem: State Transfer&lt;/h4&gt;

&lt;p&gt;A very common way to keep state between reload is to use the heap and pass pointers to objects so the host can hand it over the next reload. This requires that the plugin instances share the same allocator, it may be managed by the host or via a common crt (dynamic crt on MSVC). One limitation of this approach is with global and local static states.&lt;/p&gt;

&lt;p&gt;For the first case, using the heap model the user may decide to manage its own states by filling a struct with pointers to objects and handing it over so &lt;code&gt;cr.h&lt;/code&gt; can hold it between reloads using the &lt;code&gt;userdata&lt;/code&gt; pointer in the &lt;code&gt;cr_plugin&lt;/code&gt; context. Other than the same allocator being required, care should be taken with destructors called during unload.&lt;/p&gt;

&lt;p&gt;The second case is when dealing with static state (both global and local), it would be really annoying and highly error prone to do it by hand like copying over to the heap and restoring (and dealing with a lot of issues this may cause). In this situation, &lt;code&gt;cr.h&lt;/code&gt; will magically do all the hard work with all necessary static data tagged with a macro &lt;code&gt;CR_STATE&lt;/code&gt;. These states will get saved and copied over to the newly loaded instance and everything will just work.. most of the time. The catch here is that depending on how much your binary changes, things may not work as we&amp;rsquo;re dealing with opaque memory copying and addresses that may change.&lt;/p&gt;

&lt;p&gt;Here some things to be aware when using &lt;code&gt;CR_STATE&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Do not save objects that have pointers to anything that is not in the heap;&lt;/li&gt;
&lt;li&gt;Do not save objects that have non trivial constructors and destructors, they may or may not work;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;
All this is subject to change as I&amp;rsquo;ll be hardening it while using in my projects. I have some more ideas in the back of my mind on how to improve all this by using more debug info, but not sure if it is worth the effort. Enough yak shaving.&lt;/p&gt;

&lt;h3 id=&#34;development-stats&#34;&gt;Development Stats&lt;/h3&gt;

&lt;p&gt;Finally, some approximated development time statistics (as my free time is mostly in spans of 30 minutes to 1h).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Base implementation: 1h

&lt;ul&gt;
&lt;li&gt;Windows specific: 3h&lt;/li&gt;
&lt;li&gt;Linux specific: 4h&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Samples: 3h&lt;/li&gt;
&lt;li&gt;Tests: 2h&lt;/li&gt;
&lt;li&gt;Documentation: 2h&lt;/li&gt;
&lt;li&gt;This Post: 7h&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;
Total: 22h (5 weeks, ~4h/week)&lt;/p&gt;

&lt;h3 id=&#34;feedback&#34;&gt;Feedback&lt;/h3&gt;

&lt;p&gt;Please, post corrections and suggestions about this post by opening an issue &lt;a href=&#34;https://github.com/fungos/fungos.github.io/issues/&#34;&gt;here&lt;/a&gt;. Any help/improvement is appreciated.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>https://fungos.github.io/about/</link>
      <pubDate>Sat, 12 Aug 2017 13:00:00 EST</pubDate>
      <author>Alexander Ivanov</author>
      <guid>https://fungos.github.io/about/</guid>
      <description>&lt;p&gt;Hi, my name is Danny Angelo Carminati Grein and I live in Qu√©bec City.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m currently a Senior Technology Programmer at &lt;a href=&#34;http://beenox.com/&#34;&gt;Beenox Inc.&lt;/a&gt;/Activision developing AAA games, you can find a bit more about my professional background over my &lt;a href=&#34;https://www.linkedin.com/in/dannygrein&#34;&gt;LinkedIn profile&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m no writter, but I&amp;rsquo;m trying to get out of my confort zone, consider it before anything else.&lt;/p&gt;

&lt;p&gt;This is a personal blog and as such the opinions expressed here represent my own and not those of my employer. My opinions may generally be biased or simple wrong.&lt;/p&gt;

&lt;p&gt;This blog is built with &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; and is based over the theme &lt;a href=&#34;https://themes.gohugo.io/simple-a/&#34;&gt;Simple-A&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Setting Up a Rust Environment on Windows</title>
      <link>https://fungos.github.io/blog/2017/08/12/setting-up-a-rust-environment-on-windows/</link>
      <pubDate>Sat, 12 Aug 2017 13:00:00 EST</pubDate>
      <author>Alexander Ivanov</author>
      <guid>https://fungos.github.io/blog/2017/08/12/setting-up-a-rust-environment-on-windows/</guid>
      <description>

&lt;p&gt;When I talk about Rust, one question that comes the most is about tooling and debugging. Online this can be seen a lot, mainly about debugging on Windows.&lt;/p&gt;

&lt;p&gt;So I&amp;rsquo;ve decided to write a little guide mostly to practice my written English and bootstrap this blog, but also to document the current steps needed to set a good Windows Rust environment.&lt;/p&gt;

&lt;p&gt;Be warned that it may miss some details or be too superficial for some people.&lt;/p&gt;

&lt;p&gt;The setup described here is the one I&amp;rsquo;ve been using Rust on Windows (and approximately equivalent on GNU/Linux) for some time and I believe it to be the ideal setup for myself, at least for the moment.&lt;/p&gt;

&lt;p&gt;I also believe that this setup is already better than current C or C++ (take it with a grain of salt anyway), first because of Cargo, but also due the recent improvements with &lt;a href=&#34;https://github.com/rust-lang-nursery/rls&#34;&gt;Rust Language Server (RLS)&lt;/a&gt; and in part due to Rust use of LLVM and the compatibility with C ABI, it can piggyback on C/C++ tools like GDB, Valgrind, profilers and lots more.&lt;/p&gt;

&lt;p&gt;This makes setting up projects, developing and debugging a breeze if compared to C/C++, even if compared with Visual Studio and Visual Assist. Only Debugging is not as clean as debugging C code, its more like an equivalent of debugging a heavy STL C++ code base and some people may find this hard.&lt;/p&gt;

&lt;p&gt;I hope this may be helpfull in some way to these getting started with Rust on Windows.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: My background is with C and C++, so I tend to compare things with these languages and probably use terminology from this background.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;c-build-tools&#34;&gt;C++ Build Tools&lt;/h2&gt;

&lt;p&gt;The first and most important thing to a working Rust environment is to have one C++ toolchain available so Rust can build C or C++ (&amp;ldquo;-sys&amp;rdquo;) crates and link against Windows libraries.&lt;/p&gt;

&lt;p&gt;This can be achieved in two ways:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Having a Visual Studio C++ installation, or;&lt;/li&gt;
&lt;li&gt;Installing the smaller &lt;a href=&#34;http://landinghub.visualstudio.com/visual-cpp-build-tools&#34;&gt;Visual C++ Build Tools&lt;/a&gt; for a standalone toolchain;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;rustup&#34;&gt;Rustup&lt;/h2&gt;

&lt;p&gt;Rustup is the responsible for managing Rust compilers, Cargo, documentation, and so on. This tool is the entry point for a complete Rust environment and as Cargo, is a central part of Rust tooling.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: To avoid any confusion with older Rust installations, if you&amp;rsquo;d already tried Rust before without Rustup, I suggest to uninstall everything (Rust, Cargo and anything related).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Installing Rustup is straightforward, download it &lt;a href=&#34;https://www.rustup.rs/&#34;&gt;here&lt;/a&gt; and then run it. A console window will launch as shown here:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://fungos.github.io/images/1/rustup-console.png&#34; alt=&#34;rustup-init.exe&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then go with the default installation (option 1). As shown in the screenshot, it will install a stable Rust for MSVC ABI.&lt;/p&gt;

&lt;p&gt;Or by command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dos&#34;&gt;&amp;gt; rustup-init.exe -y
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;rust-toolchain&#34;&gt;Rust Toolchain&lt;/h3&gt;

&lt;p&gt;With Rustup installed, most of the toolchain management is done in the command line with the Rustup command. Getting used to it will surely help in the future.&lt;/p&gt;

&lt;p&gt;First, lets update everything to be sure (required if it is not a fresh install):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dos&#34;&gt;&amp;gt; rustup update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, adding the nightly version of the compiler for trying experimental features and to be able to compile an useful tool (Clippy):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dos&#34;&gt;&amp;gt; rustup install nightly
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;rls-and-components&#34;&gt;RLS and Components&lt;/h3&gt;

&lt;p&gt;RLS is essential and the main component, but it comes with its own requirements: the Rust source code, documentation and the analysis component.
The source and documentation will be used by analysis component to feed RLS with required data about existing crates and code. Read more about what RLS can do &lt;a href=&#34;http://www.ncameron.org/blog/what-the-rls-can-do/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Basically, RLS enable auto-completion, documentation tooltips and related code editing features to any IDE supporting the Microsoft Language Server protocol. It is in a way equivalent to C++ Intellisense or Visual Assist. Although it is still under heavy development, I think it is already more usable than both of C++ alternatives on Visual Studio.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dos&#34;&gt;&amp;gt; rustup default nightly
&amp;gt; rustup component add rust-src
&amp;gt; rustup component add rust-docs
&amp;gt; rustup component add rust-analysis
&amp;gt; rustup component add rls-preview
&amp;gt; rustup update
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: Both &lt;code&gt;rust-analysis&lt;/code&gt; and &lt;code&gt;rls&lt;/code&gt; can only be installed by using the nightly toolchain. Nightly can be set as the default toolchain or by passing the flag &lt;code&gt;--toolchain nightly&lt;/code&gt; to the Rustup command line.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;rustfmt&#34;&gt;Rustfmt&lt;/h3&gt;

&lt;p&gt;Rustfmt will automatically format the code accordingly to the current code style standard. Opposed to languages as C or C++ where each code base has its own style, Rust (and for the matter, most recent languages) enforce a standard style on the code. You may think it is too intrusive, but it is better for everyone by the end. More information about styling can be found on rustfmt &lt;a href=&#34;https://github.com/rust-lang-nursery/fmt-rfcs/blob/master/guide/guide.md&#34;&gt;RFC repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To install it, suffice to use Cargo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dos&#34;&gt;&amp;gt; cargo install rustfmt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will be used by VSCode Rust Extension to automatically format Rust code being edited.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: Rustfmt will be asked to be installed by Visual Studio Code if it isn&amp;rsquo;t already installed anyway.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But rustfmt is in active development and the recommended way is by using the nightly version:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dos&#34;&gt;&amp;gt; rustup run nightly cargo install rustfmt-nightly
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, formating code should be done by issuing the command bellow, indicating it uses the nightly toolchain otherwise and error loading its dependencies will happen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dos&#34;&gt;&amp;gt; cargo +nightly fmt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;clippy&#34;&gt;Clippy&lt;/h3&gt;

&lt;p&gt;Clippy is another jewel of Rust, it is the second best friend (after Rust compiler) on helping learning Rust and improving the code. It is a linter that will catch issues and suggest improvements, it should be used regularly and will help learning some tricks and writing idiomatic code. The downside if we can say so is that it requires a nightly compiler to install/compile it.&lt;/p&gt;

&lt;p&gt;Again, to install, use Cargo (and be sure to have the nightly toolchain in use):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dos&#34;&gt;&amp;gt; rustup run nightly cargo install clippy
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: Installing these tools with cargo means compiling them, and Rust compile times are not really the best. So, go take a coffee.&lt;/p&gt;

&lt;p&gt;Note: Clippy will be asked to be installed by Visual Studio Code if it isn&amp;rsquo;t already installed anyway.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To check a Rust project using Clippy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dos&#34;&gt;&amp;gt; cargo clippy
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;visual-studio-code&#34;&gt;Visual Studio Code&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve tried some different IDEs (take a look &lt;a href=&#34;https://areweideyet.com/&#34;&gt;here&lt;/a&gt; for some alternatives and their current support state), but I believe VSCode (at the moment) is the best and most complete mostly due to the &lt;a href=&#34;https://github.com/Microsoft/language-server-protocol&#34;&gt;Language Server Protocol&lt;/a&gt;/RLS.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: The second best is &lt;a href=&#34;https://intellij-rust.github.io/&#34;&gt;IntelliJ Rust&lt;/a&gt; and now it is &lt;a href=&#34;https://blog.jetbrains.com/blog/2017/08/04/official-support-for-open-source-rust-plugin-for-intellij-idea-clion-and-other-jetbrains-ides/&#34;&gt;officially supported by JetBrains&lt;/a&gt;. The problem is that it is heavy. I wouldn&amp;rsquo;t recommend it unless you&amp;rsquo;re already have it. Also, it does not support debugging, but this is being worked on.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Before configuring a Rust project in Visual Studio Code, some extensions are needed as these will help to edit code and debugging, and they&amp;rsquo;re pretty much all it is needed to have a working Rust IDE.&lt;/p&gt;

&lt;h3 id=&#34;extensions&#34;&gt;Extensions&lt;/h3&gt;

&lt;p&gt;All VSCode extensions here may be installed via the Extensions Panel, or by using &lt;code&gt;CTRL+P&lt;/code&gt; and typing &lt;code&gt;ext install &amp;lt;name&amp;gt;&lt;/code&gt; or by command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dos&#34;&gt;&amp;gt; code --install-extension &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;rust-rls&#34;&gt;Rust (rls)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&#34;&gt;Rust (rls)&lt;/a&gt; is a new extension (the third Rust extension already) but is already very usable, also this is the official one by the Rust Tool Team and is being worked on actively.&lt;/p&gt;

&lt;p&gt;Extension name: &lt;code&gt;rust-lang.rust&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dos&#34;&gt;&amp;gt; code --install-extension rust-lang.rust
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;c-c&#34;&gt;C/C++&lt;/h4&gt;

&lt;p&gt;This extension is needed to be able to debug native binaries using GDB, LLDB or Visual Studio Debugger.&lt;/p&gt;

&lt;p&gt;Extension name: &lt;code&gt;ms-vscode.cpptools&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dos&#34;&gt;&amp;gt; code --install-extension ms-vscode.cpptools
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will also download and install any required dependency.&lt;/p&gt;

&lt;h4 id=&#34;native-debug&#34;&gt;Native Debug&lt;/h4&gt;

&lt;p&gt;This one is not really needed, but I recommend use this to automatically enable VSCode to set breakpoints on Rust code. Otherwise, it would require tuning user settings (&lt;code&gt;CTRL+,&lt;/code&gt;) and setting &lt;code&gt;debug.allowBreakpointsEverywhere&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Extension name: &lt;code&gt;webfreak.debug&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dos&#34;&gt;&amp;gt; code --install-extension webfreak.debug
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;visualizers&#34;&gt;Visualizers&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: This section will soon be deprecated. A &lt;a href=&#34;https://github.com/rust-lang/rust/pull/43221&#34;&gt;recent commit&lt;/a&gt; on Rust, is now embedding visualization information inside PDBs. This is already valid for Nightly toolchain, but Stable still requires this manual step.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;With Rust MSVC toolchain comes some type visualizers for Visual Studio Debugger (Natvis), these can be used to ease the visualization of some very few Rust types within the Debugger. Sadly, there are still limitations of what can be specified in a Natvis file.&lt;/p&gt;

&lt;p&gt;The downside is that the installation of the visualization files are a bit manual at the moment, so this is the hardest part of all the Rust environment setup.&lt;/p&gt;

&lt;p&gt;The files in question are in &lt;code&gt;%HOMEPATH%\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib\rustlib\etc&lt;/code&gt; and must be copied to &lt;code&gt;%HOMEPATH%\.vscode\extensions\ms-vscode.cpptools-0.12.2\debugAdapters\vsdbg\bin\Visualizers&lt;/code&gt; (note the version on ms-vscode.cpptools path, this can be different for your case).&lt;/p&gt;

&lt;p&gt;If a custom visualizer is needed, an entry &lt;code&gt;&amp;quot;visualizerFile&amp;quot;&lt;/code&gt; can be set inside &lt;code&gt;launch.json&lt;/code&gt; (environment variables can be referenced as &lt;code&gt;${env:VAR}&lt;/code&gt;), so for example, one can set: &lt;code&gt;&amp;quot;visualizerFile&amp;quot;: &amp;quot;${env:HOMEPATH}/.rustup/toolchains/stable-x86_64-pc-windows-msvc/lib/rustlib/etc/libcore.natvis&amp;quot;&lt;/code&gt;. For the moment, only one file can be used, an &lt;a href=&#34;https://github.com/Microsoft/vscode-cpptools/issues/925&#34;&gt;issue&lt;/a&gt; is open to make it work with multiple files.&lt;/p&gt;

&lt;h2 id=&#34;debugging&#34;&gt;Debugging&lt;/h2&gt;

&lt;p&gt;Now that everything is in place, the last thing is configuring a Rust project to be debugged.&lt;/p&gt;

&lt;p&gt;Create a debug configuration by going to the &lt;code&gt;(1) Debug Panel&lt;/code&gt;, then clicking on the &lt;code&gt;(2) Debug Configuration Dropdown&lt;/code&gt; and then select &lt;code&gt;(3) C++ (Windows)&lt;/code&gt; option as shown below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://fungos.github.io/images/1/vscode-debug-cfg.png#center&#34; alt=&#34;debug&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://fungos.github.io/images/1/vscode-debug-msvc.png#center&#34; alt=&#34;debug&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This will open a new file in the editor, called &lt;code&gt;launch.json&lt;/code&gt; where all launch settings are managed.&lt;/p&gt;

&lt;p&gt;The initial contents of the file aren&amp;rsquo;t good because VSCode does not know details about the loaded Rust project (and I don&amp;rsquo;t believe extensions can do anything here to help with it, at least for the current version), so a little tweak is required.&lt;/p&gt;

&lt;p&gt;The current file should look as this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;version&amp;quot;: &amp;quot;0.2.0&amp;quot;,
    &amp;quot;configurations&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;(Windows) Launch&amp;quot;,
            &amp;quot;type&amp;quot;: &amp;quot;cppvsdbg&amp;quot;,
            &amp;quot;request&amp;quot;: &amp;quot;launch&amp;quot;,
            &amp;quot;program&amp;quot;: &amp;quot;enter program name, for example ${workspaceRoot}/a.exe&amp;quot;,
            &amp;quot;args&amp;quot;: [],
            &amp;quot;stopAtEntry&amp;quot;: false,
            &amp;quot;cwd&amp;quot;: &amp;quot;${workspaceRoot}&amp;quot;,
            &amp;quot;environment&amp;quot;: [],
            &amp;quot;externalConsole&amp;quot;: true
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some important things to note here are the &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;program&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;type&lt;/code&gt; should specify &lt;code&gt;cppvsdbg&lt;/code&gt; to use the MSVC Debugger and have Natvis support.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;program&lt;/code&gt; here is the path to the executable generated by rustc/Cargo. When using Cargo, normally the debug executable will be found in a path as &lt;code&gt;&amp;lt;project&amp;gt;/target/debug/&amp;lt;project&amp;gt;.exe&lt;/code&gt;. With this in mind, a good default should be to point the &lt;code&gt;program&lt;/code&gt; to &lt;code&gt;${workspaceRoot}/target/debug/${workspaceRootFolderName}.exe&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;My preferred &lt;code&gt;launch.json&lt;/code&gt; is this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;version&amp;quot;: &amp;quot;0.2.0&amp;quot;,
    &amp;quot;configurations&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;Debug&amp;quot;,
            &amp;quot;type&amp;quot;: &amp;quot;cppvsdbg&amp;quot;,
            &amp;quot;request&amp;quot;: &amp;quot;launch&amp;quot;,
            &amp;quot;program&amp;quot;: &amp;quot;${workspaceRoot}/target/debug/${workspaceRootFolderName}.exe&amp;quot;,
            &amp;quot;args&amp;quot;: [],
            &amp;quot;stopAtEntry&amp;quot;: false,
            &amp;quot;cwd&amp;quot;: &amp;quot;${workspaceRoot}&amp;quot;,
            &amp;quot;environment&amp;quot;: [],
            &amp;quot;externalConsole&amp;quot;: true
        },
        {
            &amp;quot;name&amp;quot;: &amp;quot;Release&amp;quot;,
            &amp;quot;type&amp;quot;: &amp;quot;cppvsdbg&amp;quot;,
            &amp;quot;request&amp;quot;: &amp;quot;launch&amp;quot;,
            &amp;quot;program&amp;quot;: &amp;quot;${workspaceRoot}/target/release/${workspaceRootFolderName}.exe&amp;quot;,
            &amp;quot;args&amp;quot;: [],
            &amp;quot;stopAtEntry&amp;quot;: false,
            &amp;quot;cwd&amp;quot;: &amp;quot;${workspaceRoot}&amp;quot;,
            &amp;quot;environment&amp;quot;: [],
            &amp;quot;externalConsole&amp;quot;: true
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, a way to debug release binaries is already in hand if needed for some reason.&lt;/p&gt;

&lt;h2 id=&#34;wishlist&#34;&gt;Wishlist&lt;/h2&gt;

&lt;p&gt;The missing key step here would be to have a better integration from Rust Language Extension to manipulate/fix/generate &lt;code&gt;launch.json&lt;/code&gt; for Rust projects or even better, a &lt;code&gt;cargo ide-setup &amp;lt;ide&amp;gt;&lt;/code&gt; command or something similar, where &lt;code&gt;&amp;lt;ide&amp;gt;&lt;/code&gt; could be &lt;code&gt;vscode&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This command would then be able to install the required vscode extensions if needed, and copy the natvis files to the right place, if in a windows environment.&lt;/p&gt;

&lt;h3 id=&#34;rust-env-setup-script&#34;&gt;&lt;code&gt;rust-env-setup&lt;/code&gt; Script&lt;/h3&gt;

&lt;p&gt;This is a quick power shell script I hacked together in a gist for automatizing a working Rust environment with VSCode.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: I&amp;rsquo;m not a PS guy, so do not take this for a solution.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script src=&#34;//gist.github.com/fungos/5c94a2b7ed4a5b7ea4572e54c0c96a34.js?file=rust-env-setup.ps1&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;feedback&#34;&gt;Feedback&lt;/h2&gt;

&lt;p&gt;Help me improving this text by submitting fixes for wrong wording/phrasing or typos in &lt;a href=&#34;https://github.com/fungos/fungos.github.io/issues&#34;&gt;this repo issue tracker&lt;/a&gt; or by commenting on twitter or elsewhere!&lt;/p&gt;

&lt;h2 id=&#34;updates&#34;&gt;Updates&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Fixed script to consider the fresh VSCode 64bits. Thanks @colemickens (Reddit).&lt;/li&gt;
&lt;li&gt;Fixed missing analysis component and rustfmt-nightly on text and script. Thanks @dodheim (Reddit).&lt;/li&gt;
&lt;li&gt;Added more information about how to add a natvis file into &lt;code&gt;launch.json&lt;/code&gt; and mention that soon it will not be required, as it will be automatically embedded onto PDB files.&lt;/li&gt;
&lt;li&gt;Add information and fix typo. Closes &lt;a href=&#34;https://github.com/fungos/fungos.github.io/issues/1&#34;&gt;issue #1&lt;/a&gt; by @TheCycoONE (Github).&lt;/li&gt;
&lt;li&gt;Update rustup rls component name to rls-preivew. Closes &lt;a href=&#34;https://github.com/fungos/fungos.github.io/issues/2&#34;&gt;issue #2&lt;/a&gt; by @cbordeman  (Github).&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
